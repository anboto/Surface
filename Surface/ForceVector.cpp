// SPDX-License-Identifier: Apache-2.0
// Copyright 2021 - 2025, the Anboto author and contributors
#include <Core/Core.h>
#include <Surface/Surface.h>
#include <Geom/Geom.h>

#include <Functions4U/EnableWarnings.h>

namespace Upp {
using namespace Eigen;

ForceVector &ForceVector::TransRot(double dx, double dy, double dz, double ax, double ay, double az, double cx, double cy, double cz) {
	TransRot(GetTransform(Value3D(dx, dy, dz), Value3D(ax, ay, az), Point3D(cx, cy, cz)));
	return *this;
}

ForceVector &ForceVector::TransRot(const Affine3d &aff) {
	point.TransRot(aff);
	force.t.TransRot(aff);
	return *this;
}

ForceVector &ForceVector::Translate(const Point3D &p) {
	Vector3D R = point - p;
	force.r += R%force.t;
	point = clone(p);	
	return *this;
}


// Just force, no moment
void Force6D::Add(const Vector3D &force, const Point3D &point, const Point3D &c0) {
	Vector3D R = point - c0;
	Vector3D M = R%force;
	t += force;
	r += M;							// No moment added, just the generated by the leverage arm of the force
}
	
void Force6D::Add(const Force6D &force, const Point3D &point, const Point3D &c0) {
	Vector3D R = point - c0;
	Vector3D M = R%force.t;
	t += force.t;
	r += M + force.r;
}

void Force6D::Add(const ForceVector &fv, const Point3D &c0) {
	Vector3D R = fv.point - c0;	// Leverage arm
	Vector3D M = R%fv.force.t;	// Moment generated by the leverage arm of the force
	t += fv.force.t;
	r += M + fv.force.r;
}

}
